{"version":3,"file":"transport.js","sourceRoot":"","sources":["../../../../common/src/transport.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type RemoteInfo,\n  type Socket,\n  type SocketType,\n  createSocket,\n} from \"dgram\";\n\nimport net from \"net\";\n\nimport { type AddressInfo, type Socket as TcpSocket, connect } from \"net\";\nimport { debug } from \"./log\";\nimport {\n  type Address,\n  type InterfaceAddresses,\n  findPort,\n  interfaceAddress,\n  normalizeFamilyNodeV18,\n} from \"./network\";\n\nconst log = debug(\"werift-ice:packages/ice/src/transport.ts\");\n\nexport class UdpTransport implements Transport {\n  readonly type = \"udp\";\n  readonly socket: Socket;\n  rinfo?: Partial<Pick<RemoteInfo, \"address\" | \"port\">>;\n  onData: (data: Buffer, addr: Address) => void = () => {};\n  closed: boolean = false;\n\n  private constructor(\n    private socketType: SocketType,\n    private options: {\n      portRange?: [number, number];\n      interfaceAddresses?: InterfaceAddresses;\n      port?: number;\n    } = {},\n  ) {\n    this.socket = createSocket(socketType);\n    this.socket.on(\"message\", (data, info) => {\n      if (normalizeFamilyNodeV18(info.family) === 6) {\n        [info.address] = info.address.split(\"%\"); // example fe80::1d3a:8751:4ffd:eb80%wlp82s0\n      }\n      this.rinfo = info;\n      try {\n        this.onData(data, [info.address, info.port]);\n      } catch (error) {\n        log(\"onData error\", error);\n      }\n    });\n  }\n\n  static async init(\n    type: SocketType,\n    options: {\n      portRange?: [number, number];\n      port?: number;\n      interfaceAddresses?: InterfaceAddresses;\n    } = {},\n  ) {\n    const transport = new UdpTransport(type, options);\n    await transport.init();\n    return transport;\n  }\n\n  private async init() {\n    const address = interfaceAddress(\n      this.socketType,\n      this.options.interfaceAddresses,\n    );\n    if (this.options.port) {\n      this.socket.bind({ port: this.options.port, address });\n    } else if (this.options.portRange) {\n      const port = await findPort(\n        this.options.portRange[0],\n        this.options.portRange[1],\n        this.socketType,\n        this.options.interfaceAddresses,\n      );\n      this.socket.bind({ port, address });\n    } else {\n      this.socket.bind({ address });\n    }\n    await new Promise((r) => this.socket.once(\"listening\", r));\n  }\n\n  send = async (data: Buffer, addr?: Address) => {\n    if (addr && !net.isIP(addr[0])) {\n      // if address is not resolved, need to use send callback to handle dns failure.\n      return new Promise<void>((r, f) => {\n        this.socket.send(data, addr![1], addr![0], (error) => {\n          if (error) {\n            log(\"send error\", addr, data);\n            f(error);\n          } else {\n            r();\n          }\n        });\n      });\n    } else {\n      addr = addr ?? [this.rinfo?.address!, this.rinfo?.port!];\n      // a preestablished remote address does not need a callback to verify dns.\n      // this is faster because event loop is not used per packet.\n      this.socket.send(data, addr[1], addr[0]);\n    }\n  };\n\n  get address() {\n    return this.socket.address();\n  }\n\n  get host() {\n    return this.socket.address().address;\n  }\n\n  get port() {\n    return this.socket.address().port;\n  }\n\n  close = () =>\n    new Promise<void>((r) => {\n      this.closed = true;\n      this.socket.once(\"close\", r);\n      try {\n        this.socket.close();\n      } catch (error) {\n        r();\n      }\n    });\n}\n\nexport class TcpTransport implements Transport {\n  readonly type = \"tcp\";\n  private connecting!: Promise<void>;\n  private client!: TcpSocket;\n  onData: (data: Buffer, addr: Address) => void = () => {};\n  closed = false;\n\n  private constructor(private addr: Address) {\n    this.connect();\n  }\n\n  private connect() {\n    if (this.closed) {\n      return;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n    this.connecting = new Promise((r, f) => {\n      try {\n        this.client = connect({ port: this.addr[1], host: this.addr[0] }, r);\n      } catch (error) {\n        f(error);\n      }\n    });\n\n    this.client.on(\"data\", (data) => {\n      const addr = [\n        this.client.remoteAddress!,\n        this.client.remotePort!,\n      ] as Address;\n      this.onData(data, addr);\n    });\n    this.client.on(\"end\", () => {\n      this.connect();\n    });\n    this.client.on(\"error\", (error) => {\n      console.log(\"error\", error);\n    });\n  }\n\n  private async init() {\n    await this.connecting;\n  }\n\n  static async init(addr: Address) {\n    const transport = new TcpTransport(addr);\n    await transport.init();\n    return transport;\n  }\n\n  get address() {\n    return {} as AddressInfo;\n  }\n\n  send = async (data: Buffer, addr?: Address) => {\n    await this.connecting;\n    this.client.write(data, (err) => {\n      if (err) {\n        console.log(\"err\", err);\n      }\n    });\n  };\n\n  close = async () => {\n    this.closed = true;\n    this.client.destroy();\n  };\n}\n\nexport interface Transport {\n  type: string;\n  address: AddressInfo;\n  closed: boolean;\n  onData: (data: Buffer, addr: Address) => void;\n  send: (data: Buffer, addr?: Address) => Promise<void>;\n  close: () => Promise<void>;\n}\n"]}