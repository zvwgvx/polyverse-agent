{"version":3,"file":"dtx.js","sourceRoot":"","sources":["../../../../../src/extra/processor/dtx.ts"],"names":[],"mappings":";;;AAAA,mCAAoC;AASpC,MAAa,OAAO;IAKlB,YACS,KAAa,EACZ,WAAmB;QAD3B;;;;mBAAO,KAAK;WAAQ;QACpB;;;;mBAAQ,WAAW;WAAQ;QANpB;;;;mBAAK,IAAA,mBAAU,GAAE,CAAC,QAAQ,EAAE;WAAC;QACtC;;;;;WAA2B;QACnB;;;;mBAAY,CAAC;WAAC;QACd;;;;mBAAgB,EAAE;WAAC;IAIxB,CAAC;IAEJ,MAAM;QACJ,OAAO,EAAE,GAAG,IAAI,CAAC,aAAa,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC;IAC3E,CAAC;IAED,YAAY,CAAC,EAAE,KAAK,EAAE,GAAG,EAAY;QACnC,IAAI,GAAG,EAAE,CAAC;YACR,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;QACzB,CAAC;QAED,IAAI,KAAK,EAAE,CAAC;YACV,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC5B,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;gBACrD,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;YACrB,CAAC;YAED,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;gBACtD,MAAM,YAAY,GAA4B,EAAE,CAAC;gBACjD,KACE,IAAI,IAAI,GAAG,IAAI,CAAC,iBAAiB,EACjC,IAAI,GAAG,KAAK,CAAC,IAAI,EACjB,IAAI,IAAI,IAAI,CAAC,KAAK,EAClB,CAAC;oBACD,YAAY,CAAC,IAAI,CAAC;wBAChB,KAAK,EAAE;4BACL,IAAI;4BACJ,UAAU,EAAE,KAAK,CAAC,UAAU;4BAC5B,IAAI,EAAE,IAAI,CAAC,WAAW;yBACvB;qBACF,CAAC,CAAC;oBACH,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,CAAC;gBAED,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;gBACrD,OAAO,CAAC,GAAG,YAAY,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;YACtC,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;gBACrD,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;YACrB,CAAC;QACH,CAAC;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;IAEO,IAAI;QACV,IAAI,CAAC,WAAW,GAAG,SAAgB,CAAC;IACtC,CAAC;CACF;AA5DD,0BA4DC","sourcesContent":["import { randomUUID } from \"crypto\";\n\nimport type { CodecFrame, DepacketizerOutput } from \"./depacketizer\";\nimport type { Processor } from \"./interface\";\n\nexport type DtxInput = DepacketizerOutput;\n\nexport type DtxOutput = DtxInput;\n\nexport class DtxBase implements Processor<DtxInput, DtxOutput> {\n  readonly id = randomUUID().toString();\n  previousTimestamp?: number;\n  private fillCount = 0;\n  private internalStats = {};\n  constructor(\n    public ptime: number,\n    private dummyPacket: Buffer,\n  ) {}\n\n  toJSON(): Record<string, any> {\n    return { ...this.internalStats, id: this.id, fillCount: this.fillCount };\n  }\n\n  processInput({ frame, eol }: DtxInput): DtxOutput[] {\n    if (eol) {\n      this.stop();\n      return [{ eol: true }];\n    }\n\n    if (frame) {\n      if (!this.previousTimestamp) {\n        this.previousTimestamp = frame.time;\n        this.internalStats[\"dtx\"] = new Date().toISOString();\n        return [{ frame }];\n      }\n\n      if (frame.time != this.previousTimestamp + this.ptime) {\n        const dummyPackets: { frame: CodecFrame }[] = [];\n        for (\n          let time = this.previousTimestamp;\n          time < frame.time;\n          time += this.ptime\n        ) {\n          dummyPackets.push({\n            frame: {\n              time,\n              isKeyframe: frame.isKeyframe,\n              data: this.dummyPacket,\n            },\n          });\n          this.fillCount++;\n        }\n\n        this.previousTimestamp = frame.time;\n        this.internalStats[\"dtx\"] = new Date().toISOString();\n        return [...dummyPackets, { frame }];\n      } else {\n        this.previousTimestamp = frame.time;\n        this.internalStats[\"dtx\"] = new Date().toISOString();\n        return [{ frame }];\n      }\n    }\n\n    return [];\n  }\n\n  private stop() {\n    this.dummyPacket = undefined as any;\n  }\n}\n"]}