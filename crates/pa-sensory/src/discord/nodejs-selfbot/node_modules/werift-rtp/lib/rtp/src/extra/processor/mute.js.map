{"version":3,"file":"mute.js","sourceRoot":"","sources":["../../../../../src/extra/processor/mute.ts"],"names":[],"mappings":"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","sourcesContent":["import { randomUUID } from \"crypto\";\n\nimport { int } from \"../..\";\nimport type { CodecFrame, DepacketizerOutput } from \"./depacketizer\";\nimport type { Processor } from \"./interface\";\n\nexport type MuteInput = DepacketizerOutput;\n\nexport type MuteOutput = MuteInput;\n\nexport class MuteHandlerBase implements Processor<MuteInput, MuteOutput> {\n  readonly id = randomUUID().toString();\n  private buffer: CodecFrame[][];\n  private index = 0;\n  private ended = false;\n  private baseTime?: number;\n  private currentTimestamp!: number;\n  private internalStats = {};\n  /**ms */\n  private lastCommittedTime = 0;\n  private lastExecutionTime = 0;\n  /**ms */\n  private interval: number;\n  private bufferDuration: number;\n  private bufferLength: number;\n  /**ms */\n  private lastFrameReceivedAt = 0;\n\n  constructor(\n    private output: (o: MuteOutput) => void,\n    private props: {\n      ptime: number;\n      dummyPacket: Buffer;\n      /**ms\n       * @description intervalごとに無音区間に空パケットを挿入する\n       */\n      interval: number;\n      bufferLength: number;\n    },\n  ) {\n    this.interval = props.interval;\n    this.bufferDuration = this.interval / 2;\n    this.bufferLength = this.props.bufferLength * 2;\n    this.buffer = [...new Array(this.bufferLength)].map(() => []);\n  }\n\n  toJSON(): Record<string, any> {\n    return { ...this.internalStats, id: this.id };\n  }\n\n  private executeTask() {\n    const { ptime, dummyPacket } = this.props;\n\n    const buffer = this.buffer[this.index].sort((a, b) => a.time - b.time);\n    const last = buffer.at(-1);\n    const expect = last\n      ? last.time +\n        // offset\n        ptime\n      : this.currentTimestamp;\n\n    if (expect < this.currentTimestamp + this.bufferDuration) {\n      for (\n        let time = expect;\n        time < this.currentTimestamp + this.bufferDuration;\n        time += ptime\n      ) {\n        buffer.push({\n          time,\n          data: dummyPacket,\n          isKeyframe: true,\n        });\n      }\n    }\n    this.currentTimestamp += this.bufferDuration;\n    this.internalStats[\"mute\"] = new Date().toISOString();\n\n    this.buffer[this.index] = [];\n    buffer.forEach((frame) => {\n      this.output({ frame });\n      this.lastCommittedTime = frame.time;\n    });\n\n    this.index++;\n    if (this.index === this.bufferLength) {\n      this.index = 0;\n    }\n  }\n\n  private stop() {\n    this.ended = true;\n    this.buffer = [];\n    this.output = undefined as any;\n  }\n\n  processInput = ({ frame, eol }: MuteInput): MuteOutput[] => {\n    if (!frame) {\n      this.stop();\n      return [{ eol }];\n    }\n\n    if (this.ended) {\n      return [];\n    }\n\n    if (this.baseTime == undefined) {\n      this.baseTime = frame.time;\n      this.currentTimestamp = this.baseTime;\n      this.lastExecutionTime = this.baseTime;\n      this.lastCommittedTime = this.baseTime;\n      this.lastFrameReceivedAt = Date.now();\n    }\n\n    // 過去のフレームを捨てる\n    if (frame.time < this.lastCommittedTime) {\n      return [];\n    }\n\n    // NTPの同期ずれが疑われるので捨てる\n    const now = Date.now();\n    const gap = 5000; // RTCP SR interval;\n    const lastCommittedElapsed = frame.time - this.lastCommittedTime;\n    const lastFrameReceivedElapsed = now - this.lastFrameReceivedAt;\n    if (gap < lastFrameReceivedElapsed && lastCommittedElapsed < gap) {\n      this.internalStats[\"invalidFrameTime\"] = {\n        count: (this.internalStats[\"invalidFrameTime\"]?.count ?? 0) + 1,\n        at: new Date().toISOString(),\n        lastCommittedElapsed,\n        lastFrameReceivedElapsed,\n      };\n      return [];\n    }\n    this.lastFrameReceivedAt = now;\n\n    const elapsed = frame.time - this.baseTime;\n    const index = int(elapsed / this.bufferDuration) % this.bufferLength;\n    this.buffer[index].push(frame);\n\n    const lastExecution = frame.time - this.lastExecutionTime;\n    if (lastExecution >= this.interval) {\n      const times = int(lastExecution / this.bufferDuration) - 1;\n      this.lastExecutionTime = this.currentTimestamp;\n      for (let i = 0; i < times; i++) {\n        this.executeTask();\n        this.lastExecutionTime += this.bufferDuration;\n      }\n    }\n\n    return [];\n  };\n}\n"]}