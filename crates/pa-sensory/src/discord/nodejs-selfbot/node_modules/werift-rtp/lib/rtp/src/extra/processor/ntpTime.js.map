{"version":3,"file":"ntpTime.js","sourceRoot":"","sources":["../../../../../src/extra/processor/ntpTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { randomUUID } from \"crypto\";\n\nimport {\n  type RtcpPacket,\n  RtcpSrPacket,\n  type RtpPacket,\n  ntpTime2Sec,\n} from \"../..\";\nimport type { Processor } from \"./interface\";\nimport { Max32Uint } from \"./webm\";\n\nexport type NtpTimeInput = {\n  rtp?: RtpPacket;\n  eol?: boolean;\n  rtcp?: RtcpPacket;\n};\n\nexport interface NtpTimeOutput {\n  rtp?: RtpPacket;\n  /**ms */\n  time?: number;\n  eol?: boolean;\n}\n\nexport class NtpTimeBase implements Processor<NtpTimeInput, NtpTimeOutput> {\n  readonly id = randomUUID().toString();\n  private baseNtpTimestamp?: bigint;\n  private baseRtpTimestamp?: number;\n  private latestNtpTimestamp?: bigint;\n  private latestRtpTimestamp?: number;\n  private currentElapsed = 0;\n  private buffer: RtpPacket[] = [];\n  private internalStats = {};\n  started = false;\n\n  constructor(public clockRate: number) {}\n\n  toJSON(): Record<string, any> {\n    return {\n      ...this.internalStats,\n      id: this.id,\n      baseRtpTimestamp: this.baseRtpTimestamp,\n      latestRtpTimestamp: this.latestRtpTimestamp,\n      baseNtpTimestamp:\n        this.baseNtpTimestamp && ntpTime2Sec(this.baseNtpTimestamp),\n      latestNtpTimestamp:\n        this.latestNtpTimestamp && ntpTime2Sec(this.latestNtpTimestamp),\n      bufferLength: this.buffer.length,\n      currentElapsed: this.currentElapsed,\n      clockRate: this.clockRate,\n    };\n  }\n\n  private stop() {\n    this.buffer = [];\n    this.internalStats = {};\n  }\n\n  processInput({ rtcp, rtp, eol }: NtpTimeInput): NtpTimeOutput[] {\n    if (eol) {\n      this.stop();\n      return [{ eol: true }];\n    }\n\n    if (rtcp && rtcp.type === RtcpSrPacket.type) {\n      const { ntpTimestamp, rtpTimestamp } = rtcp.senderInfo;\n      this.latestNtpTimestamp = ntpTimestamp;\n      this.latestRtpTimestamp = rtpTimestamp;\n\n      if (this.baseNtpTimestamp == undefined) {\n        this.baseNtpTimestamp = ntpTimestamp;\n        this.baseRtpTimestamp = rtpTimestamp;\n      }\n\n      this.internalStats[\"ntpReceived\"] = new Date().toISOString();\n      this.started = true;\n    }\n\n    if (rtp) {\n      this.buffer.push(rtp);\n      this.internalStats[\"payloadType\"] = rtp.header.payloadType;\n\n      const res: NtpTimeOutput[] = [];\n\n      if (\n        this.baseRtpTimestamp == undefined ||\n        this.baseNtpTimestamp == undefined ||\n        this.latestNtpTimestamp == undefined ||\n        this.latestRtpTimestamp == undefined\n      ) {\n        return [];\n      }\n\n      for (const rtp of this.buffer) {\n        const ntp = this.updateNtp(rtp.header.timestamp);\n        const ms = ntp * 1000;\n        const time = Math.round(ms);\n        res.push({ rtp, time });\n\n        this.internalStats[\"timeSource\"] =\n          new Date().toISOString() + \" time:\" + time;\n      }\n      this.buffer = [];\n      return res;\n    }\n\n    return [];\n  }\n\n  /**\n   *\n   * @param rtpTimestamp\n   * @returns sec\n   */\n  private calcNtp({\n    rtpTimestamp,\n    baseNtpTimestamp,\n    baseRtpTimestamp,\n    elapsedOffset,\n  }: {\n    rtpTimestamp: number;\n    baseRtpTimestamp: number;\n    baseNtpTimestamp: bigint;\n    elapsedOffset: number;\n  }) {\n    const rotate =\n      Math.abs(rtpTimestamp - baseRtpTimestamp) > (Max32Uint / 4) * 3;\n\n    const elapsed = rotate\n      ? rtpTimestamp + Max32Uint - baseRtpTimestamp\n      : rtpTimestamp - baseRtpTimestamp;\n    const elapsedSec = elapsed / this.clockRate;\n\n    // sec\n    const ntp = ntpTime2Sec(baseNtpTimestamp) + elapsedOffset + elapsedSec;\n    return { ntp, elapsedSec };\n  }\n\n  private updateNtp(rtpTimestamp: number) {\n    this.internalStats[\"inputRtp\"] = rtpTimestamp;\n\n    const base = this.calcNtp({\n      rtpTimestamp,\n      baseNtpTimestamp: this.baseNtpTimestamp!,\n      baseRtpTimestamp: this.baseRtpTimestamp!,\n      elapsedOffset: this.currentElapsed,\n    });\n    const latest = this.calcNtp({\n      rtpTimestamp,\n      baseNtpTimestamp: this.latestNtpTimestamp!,\n      baseRtpTimestamp: this.latestRtpTimestamp!,\n      elapsedOffset: 0,\n    });\n\n    this.internalStats[\"calcBaseNtp\"] = base.ntp;\n    this.internalStats[\"calcLatestNtp\"] = latest.ntp;\n\n    if (base.ntp < latest.ntp) {\n      // update baseNtp\n      this.baseNtpTimestamp = this.latestNtpTimestamp;\n      this.baseRtpTimestamp = this.latestRtpTimestamp;\n      this.currentElapsed = 0;\n      this.internalStats[\"calcNtp\"] = latest.ntp;\n      return latest.ntp;\n    } else {\n      this.currentElapsed += base.elapsedSec;\n      this.baseRtpTimestamp = rtpTimestamp;\n      this.internalStats[\"calcNtp\"] = base.ntp;\n      return base.ntp;\n    }\n  }\n}\n"]}