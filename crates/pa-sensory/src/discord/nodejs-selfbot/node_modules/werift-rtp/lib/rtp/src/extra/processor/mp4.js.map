{"version":3,"file":"mp4.js","sourceRoot":"","sources":["../../../../../src/extra/processor/mp4.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event } from \"../../imports/common\";\n\nimport { OpusRtpPayload, buffer2ArrayBuffer } from \"../..\";\nimport {\n  type DataType,\n  Mp4Container,\n  type Mp4SupportedCodec,\n  annexb2avcc,\n} from \"../container/mp4\";\nimport type { AVProcessor } from \"./interface\";\n\nexport type Mp4Input = {\n  frame?: {\n    data: Buffer;\n    isKeyframe: boolean;\n    /**ms */\n    time: number;\n  };\n  eol?: boolean;\n};\n\nexport interface Mp4Output {\n  type: DataType;\n  timestamp: number;\n  duration: number;\n  data: Uint8Array;\n  eol?: boolean;\n  kind: \"audio\" | \"video\";\n}\n\nexport interface MP4Option {\n  /**ms */\n  duration?: number;\n  encryptionKey?: Buffer;\n  strictTimestamp?: boolean;\n}\n\nexport class MP4Base implements AVProcessor<Mp4Input> {\n  private internalStats = {};\n  private container: Mp4Container;\n  stopped = false;\n  onStopped = new Event();\n\n  constructor(\n    public tracks: Track[],\n    private output: (output: Mp4Output) => void,\n    private options: MP4Option = {},\n  ) {\n    this.container = new Mp4Container({\n      track: {\n        audio: !!this.tracks.find((t) => t.kind === \"audio\"),\n        video: !!this.tracks.find((t) => t.kind === \"video\"),\n      },\n    });\n    this.container.onData.subscribe((data) => {\n      this.output(data);\n    });\n  }\n\n  toJSON(): Record<string, any> {\n    return {\n      ...this.internalStats,\n    };\n  }\n\n  processAudioInput = ({ frame }: Mp4Input) => {\n    const track = this.tracks.find((t) => t.kind === \"audio\")!;\n\n    if (frame) {\n      if (!this.container.audioTrack) {\n        this.container.write({\n          codec: track.codec,\n          description: buffer2ArrayBuffer(\n            OpusRtpPayload.createCodecPrivate(),\n          ) as ArrayBuffer,\n          numberOfChannels: 2,\n          sampleRate: track.clockRate,\n          track: \"audio\",\n        });\n      } else {\n        this.container.write({\n          byteLength: frame.data.length,\n          duration: null,\n          timestamp: frame.time * 1000,\n          type: \"key\",\n          copyTo: (destination) => {\n            //@ts-expect-error\n            frame.data.copy(destination);\n          },\n          track: \"audio\",\n        });\n      }\n    }\n  };\n\n  processVideoInput = ({ frame }: Mp4Input) => {\n    const track = this.tracks.find((t) => t.kind === \"video\")!;\n\n    if (frame) {\n      if (!this.container.videoTrack) {\n        if (frame.isKeyframe) {\n          const avcc = annexb2avcc(frame.data);\n\n          const [displayAspectWidth, displayAspectHeight] = computeRatio(\n            track.width!,\n            track.height!,\n          );\n\n          this.container.write({\n            codec: track.codec,\n            codedWidth: track.width,\n            codedHeight: track.height,\n            description: avcc.buffer as ArrayBuffer,\n            displayAspectWidth,\n            displayAspectHeight,\n            track: \"video\",\n          });\n          this.container.write({\n            byteLength: frame.data.length,\n            duration: null,\n            timestamp: frame.time * 1000,\n            type: \"key\",\n            copyTo: (destination) => {\n              //@ts-expect-error\n              frame.data.copy(destination);\n            },\n            track: \"video\",\n          });\n        }\n      } else {\n        this.container.write({\n          byteLength: frame.data.length,\n          duration: null,\n          timestamp: frame.time * 1000,\n          type: frame.isKeyframe ? \"key\" : \"delta\",\n          copyTo: (destination) => {\n            //@ts-expect-error\n            frame.data.copy(destination);\n          },\n          track: \"video\",\n        });\n      }\n    }\n  };\n\n  protected start() {}\n\n  stop() {}\n}\n\nfunction computeRatio(a: number, b: number) {\n  function gcd(x: number, y: number) {\n    while (y !== 0) {\n      const temp = y;\n      y = x % y;\n      x = temp;\n    }\n    return x;\n  }\n\n  const divisor = gcd(a, b);\n  return [a / divisor, b / divisor];\n}\n\nexport interface Track {\n  width?: number;\n  height?: number;\n  kind: \"audio\" | \"video\";\n  codec: Mp4SupportedCodec;\n  clockRate: number;\n  trackNumber: number;\n}\n"]}