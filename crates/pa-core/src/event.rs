use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// The platform a message originates from.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Platform {
    Discord,
    Telegram,
    Cli,
}

impl std::fmt::Display for Platform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Platform::Discord => write!(f, "Discord"),
            Platform::Telegram => write!(f, "Telegram"),
            Platform::Cli => write!(f, "CLI"),
        }
    }
}

// ─── Raw Event ───────────────────────────────────────────────

/// A raw, unprocessed event from a sensory worker (Discord/Telegram/...).
/// This is the first event emitted when a message is received.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawEvent {
    pub platform: Platform,
    pub channel_id: String,
    pub message_id: String,
    pub user_id: String,
    pub username: String,
    pub content: String,
    /// Whether this message mentions/tags the bot directly.
    pub is_mention: bool,
    /// Whether this is a direct message (private channel)
    pub is_dm: bool,
    pub timestamp: DateTime<Utc>,
}

// ─── Intent Event ────────────────────────────────────────────

/// The intent classification result from the SLM.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Intent {
    Command,
    Question,
    ChitChat,
    Insult,
    Noise,
    ComplexQuery,
}

/// Sentiment analysis result.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Sentiment {
    Positive,
    Neutral,
    Negative,
}

/// Event emitted after the SLM classifies a raw message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IntentEvent {
    /// Reference back to the original raw event
    pub source: RawEvent,
    pub intent: Intent,
    pub sentiment: Sentiment,
    /// Whether the SLM recommends escalating to Cloud LLM
    pub needs_cloud: bool,
    /// Confidence score (0.0 - 1.0)
    pub confidence: f32,
}

// ─── Response Event ──────────────────────────────────────────

/// Where the response was generated from.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ResponseSource {
    /// Generated locally by the SLM
    LocalSLM,
    /// Generated by the Cloud LLM (Gemini/OpenAI)
    CloudLLM,
    /// A template/canned response
    Template,
}

/// A response to be sent back to the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseEvent {
    /// Target platform to send the response to
    pub platform: Platform,
    pub channel_id: String,
    /// Optional: reply to a specific message
    pub reply_to_message_id: Option<String>,
    /// Who Ryuuko is replying to (username)
    pub reply_to_user: Option<String>,
    /// Whether this response is in a DM (skip reply-tag)
    pub is_dm: bool,
    pub content: String,
    pub source: ResponseSource,
}

/// A fully completed turn from the bot after all streaming chunks are sent.
/// Used for saving full responses to long-term memory.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotTurnCompletion {
    pub platform: Platform,
    pub channel_id: String,
    pub reply_to_message_id: Option<String>,
    pub reply_to_user: Option<String>,
    pub content: String,
}

// ─── Biology Event ───────────────────────────────────────────

/// Internal biology state change events.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BiologyEventKind {
    EnergyChanged { delta: f32, reason: String },
    MoodChanged { new_mood: String, trigger: String },
    SleepStarted,
    SleepEnded,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BiologyEvent {
    pub kind: BiologyEventKind,
    pub timestamp: DateTime<Utc>,
}

// ─── System Event ────────────────────────────────────────────

/// System-level control events for the supervisor / coordinator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SystemEvent {
    WorkerStarted { name: String },
    WorkerStopped { name: String },
    WorkerError { name: String, error: String },
    ShutdownRequested,
    HealthCheckRequest,
}

// ─── Unified Event ───────────────────────────────────────────

/// The unified event type that flows through the entire event bus.
/// Every event in the system is wrapped in this enum.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Event {
    Raw(RawEvent),
    Intent(IntentEvent),
    Response(ResponseEvent),
    BotTurnCompletion(BotTurnCompletion),
    Biology(BiologyEvent),
    System(SystemEvent),
}

impl Event {
    /// Helper to check if this is a system event
    pub fn is_system(&self) -> bool {
        matches!(self, Event::System(_))
    }

    /// Helper to check if this is a raw sensory event
    pub fn is_raw(&self) -> bool {
        matches!(self, Event::Raw(_))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_raw_event_serialization() {
        let event = RawEvent {
            platform: Platform::Discord,
            channel_id: "123".to_string(),
            message_id: "456".to_string(),
            user_id: "789".to_string(),
            username: "TestUser".to_string(),
            content: "Hello agent!".to_string(),
            is_mention: false,
            is_dm: false,
            timestamp: Utc::now(),
        };

        let json = serde_json::to_string(&event).unwrap();
        let deserialized: RawEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.platform, Platform::Discord);
        assert_eq!(deserialized.content, "Hello agent!");
    }

    #[test]
    fn test_event_enum_variants() {
        let raw = Event::Raw(RawEvent {
            platform: Platform::Telegram,
            channel_id: "ch1".to_string(),
            message_id: "m1".to_string(),
            user_id: "u1".to_string(),
            username: "user".to_string(),
            content: "test".to_string(),
            is_mention: false,
            is_dm: false,
            timestamp: Utc::now(),
        });

        assert!(raw.is_raw());
        assert!(!raw.is_system());

        let sys = Event::System(SystemEvent::ShutdownRequested);
        assert!(sys.is_system());
        assert!(!sys.is_raw());
    }
}
